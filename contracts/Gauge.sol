// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;


import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "./interfaces/IVotingIncentives.sol";
import "./interfaces/IFeeVault.sol";
import "./interfaces/IPairInfo.sol";
import "./interfaces/IGauge.sol";
import "./interfaces/IGaugeFactory.sol";
import "./interfaces/IWeightedPoolsSimple.sol";

import "./libraries/GaugeMath.sol";

contract Gauge is ReentrancyGuard, Ownable, Pausable, IGauge {

    using SafeERC20 for IERC20;

    /// @dev flag to put in emergency mode this contract
    bool public emergency;
    /// @dev flag to define if is weighted
    bool internal immutable isWeighted;

    /// @dev Duration of the reward distribution
    uint256 public constant DURATION = 1 weeks;
    /// @dev total supply of the deposit
    uint256 internal _totalSupply;

    /// @dev Fee vault contract address
    address public feeVault;
    /// @dev list of all reward tokens
    address[] public rewardTokens;

    /// @dev Map reward token with its end period. Token => timestamp
    mapping(address => uint256) internal _periodFinish;
    /// @dev Map a reward token with its reward rate. Token => token/seconds
    mapping(address => uint256) internal _rewardRate;
    /// @dev Map a reward token with its last update time. Token => timestamp
    mapping(address => uint256) internal _lastUpdateTime;
    /// @dev Map a reward token with its single reward token per token deposit. Token => amount per deposit
    mapping(address => uint256) internal _rewardPerTokenStored;
    /// @dev Map if token is a reward token. Token => status
    mapping(address => bool) public isRewardToken;
    /// @dev Map an address of a user to the amount of reward paid for each reward token. User => Token => Amount
    mapping(address => mapping(address => uint256)) internal _userRewardPerTokenPaid;
    /// @dev Map an address of a user to the rewards that needs to be paid. User => Token => Amount
    mapping(address => mapping(address => uint256)) internal _rewards;
    /// @dev Map the deposit of a user. Token => Amount
    mapping(address => uint256) internal _balances;

    /// @dev The underlying LP to deposit
    IERC20 public immutable TOKEN;
    /// @dev The voting incentives contract
    IVotingIncentives public votingIncentives;


    /// @dev modifier to control if msg.sender is the distribution contract/eoa
    modifier onlyDistribution() {
        require(msg.sender == IGaugeFactory(owner()).epochDistributor(), "!distro");
        _;
    }

    /// @dev modifier to check if this.contract is in emergency mode
    modifier isNotEmergency() {
        require(emergency == false);
        _;
    }

    /// @notice Deploy contract
    /// @param _rewardTokens    tokens to add as incentive
    /// @param _token           underlying token of the gauge
    /// @param _feeVault        where to get fees generated by the underlying token
    /// @param _votingIncentives address of the voting incentives contract
    /// @param _isWeighted      whether this gauge is for a weighted pool
    constructor(address[] memory _rewardTokens,address _token, address _feeVault, address _votingIncentives, bool _isWeighted) {
        require(_token != address(0), 'Addr0');
        require(_feeVault != address(0), 'Addr0');

        // add tokens
        uint i;
        for(i; i < _rewardTokens.length; i++){
            if(_rewardTokens[i] != address(0)){
                isRewardToken[_rewardTokens[i]] = true;
                rewardTokens.push(_rewardTokens[i]);
            }
        }
        isWeighted = _isWeighted;
        TOKEN = IERC20(_token);                 // underlying (LP)
        feeVault = _feeVault;                   // where to claim fees
        if(_votingIncentives != address(0)) votingIncentives = IVotingIncentives(_votingIncentives);
        emergency = false;                       // emergency flag
    }


    /* -----------------------------------------------------------------------------
    --------------------------------------------------------------------------------
    --------------------------------------------------------------------------------
                                    ONLY OWNER
    --------------------------------------------------------------------------------
    --------------------------------------------------------------------------------
    ----------------------------------------------------------------------------- */


    ///@notice set feeVault address
    function setFeeVault(address _feeVault) external onlyOwner {
        require(_feeVault != address(0), "Addr0");
        feeVault = _feeVault;
        emit SetFeeVault(_feeVault);
    }


    /// @notice Set the Voting Incentives
    function setVotingIncentives(address _vi) external onlyOwner {
        require(_vi != address(0), "Addr0");
        votingIncentives = IVotingIncentives(_vi);
        emit SetVotingIncentives(_vi);
    }

    /// @notice Activate the Emergency Mode
    function activateEmergencyMode() external onlyOwner {
        require(emergency == false);
        emergency = true;
        emit ActivateEmergencyMode();
    }

    /// @notice Deactivate the Emergency Mode
    function stopEmergencyMode() external onlyOwner {
        require(emergency == true);
        emergency = false;
        emit StopEmergencyMode();
    }

    /// @notice Pause contract
    /// @param status   true = pause, false = unpause
    function pause(bool status) external onlyOwner {
        status ? _pause() : _unpause();
    }

    /// @notice Add a new reward token
    function addRewardToken(address _token) external onlyOwner {
        require(!isRewardToken[_token], '!isRewardToken');
        require(_token != address(0), 'Addr0');
        isRewardToken[_token] = true;
        rewardTokens.push(_token);
        emit AddRewardToken(_token);

    }

    /// @notice Remove a reward token
    function removeRewardToken(address _token) external onlyOwner {
        require(isRewardToken[_token], '!isRewardToken');
        uint256 len = rewardTokens.length;
        uint i;
        for(i; i < len; i++){
            if(rewardTokens[i] == _token){
                _clearTokenInfo(_token, i);
                emit RemoveRewardToken(_token);
                break;
            }
        }
    }

    /// @dev internal function to remove the token from the list
    function _clearTokenInfo(address _token, uint256 i) internal {
        rewardTokens[i] = rewardTokens[rewardTokens.length -1];
        rewardTokens.pop();
        isRewardToken[_token] = false;
    }


    /* -----------------------------------------------------------------------------
    --------------------------------------------------------------------------------
    --------------------------------------------------------------------------------
                                    VIEW FUNCTIONS
    --------------------------------------------------------------------------------
    --------------------------------------------------------------------------------
    ----------------------------------------------------------------------------- */
    /// @notice Read total length of reward tokens
    function rewardTokensLength() external view returns(uint256){
        return rewardTokens.length;
    }

    ///@notice total supply held
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    ///@notice balance of a user
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    /// @notice Reward per seconds
    function rewardRate(address _token) external view returns(uint256){
        return _rewardRate[_token];
    }

    ///@notice  reward for a single deposited token
    function rewardPerToken(address _token) external view returns(uint256) {
        return _rewardPerToken(_token);
    }

    ///@notice get total reward for the duration
    function rewardForDuration(address _token) external view returns (uint256) {
        return _rewardRate[_token] * DURATION;
    }

    ///@notice see earned rewards for user
    function earned(address _account, address _token) external view returns (uint256) {
        return _earned(_account, _token);
    }

    /// @notice see earned reward for all tokens
    function earnedAll(address _account) external view returns(uint256[] memory amounts) {
        uint256 i;
        uint256 len = rewardTokens.length;
        address _token;
        amounts = new uint256[](len);
        for(i;i<len;i++){
            _token = rewardTokens[i];
            amounts[i] = _earned(_account, _token);
        }
    }

    /// @notice Read when reward token period terminate
    function periodFinish(address _token) external view returns (uint256) {
        return _periodFinish[_token];
    }



    /* -----------------------------------------------------------------------------
    --------------------------------------------------------------------------------
    --------------------------------------------------------------------------------
                                    USER INTERACTION
    --------------------------------------------------------------------------------
    --------------------------------------------------------------------------------
    ----------------------------------------------------------------------------- */


    ///@notice deposit all TOKEN of msg.sender
    function depositAll() external whenNotPaused {
        _deposit(TOKEN.balanceOf(msg.sender), msg.sender);
    }

    ///@notice deposit amount TOKEN
    function deposit(uint256 amount) external whenNotPaused  {
        _deposit(amount, msg.sender);
    }

    ///@notice deposit internal
    function _deposit(uint256 amount, address account) internal nonReentrant isNotEmergency {
        require(amount > 0, "amnt0");
        _updateAllRewards(account);

        _balances[account] += amount;
        _totalSupply += amount;

        TOKEN.safeTransferFrom(account, address(this), amount);

        emit Deposit(account, amount);
    }

    ///@notice withdraw all token and harvest rewardToken
    function withdrawAllAndHarvest() external whenNotPaused {
        _withdraw(_balances[msg.sender]);
        _getReward(msg.sender);
    }

    ///@notice withdraw all token
    function withdrawAll() external whenNotPaused {
        _withdraw(_balances[msg.sender]);
    }

    ///@notice withdraw a certain amount of TOKEN
    function withdraw(uint256 amount) external whenNotPaused {
        _withdraw(amount);
    }

    ///@notice withdraw internal
    function _withdraw(uint256 amount) internal nonReentrant isNotEmergency {
        require(amount > 0, "amnt0");
        require(_balances[msg.sender] > 0, "bal0");
        _updateAllRewards(msg.sender);

        _totalSupply -= amount;
        _balances[msg.sender] -= amount;


        TOKEN.safeTransfer(msg.sender, amount);

        emit Withdraw(msg.sender, amount);
    }

    /// @notice Withdraw all user balance if emergency is active
    function emergencyWithdraw() external nonReentrant {
        require(emergency);
        require(_balances[msg.sender] > 0, "bal0");

        uint256 _amount = _balances[msg.sender];
        _totalSupply -= _amount;
        _balances[msg.sender] = 0;

        TOKEN.safeTransfer(msg.sender, _amount);
        emit Withdraw(msg.sender, _amount);
    }


    /// @notice Withdraw 'amount' user balance if emergency is active
    function emergencyWithdrawAmount(uint256 _amount) external nonReentrant {
        require(emergency);
        require(_balances[msg.sender] >= _amount, "no bal");

        _totalSupply -= _amount;
        _balances[msg.sender] -= _amount;
        TOKEN.safeTransfer(msg.sender, _amount);
        emit Withdraw(msg.sender, _amount);
    }

    /// @notice User harvest function
    /// @dev this is called only from an external claimer contract that pass msg.sender as user. Done to allow multiple gauge claim in 1 tx
    function getRewardFor(address user) external nonReentrant whenNotPaused {
        require(msg.sender == IGaugeFactory(owner()).claimer());
        _getReward(user);
    }

    ///@notice User harvest function for all reward tokens
    function getReward() external nonReentrant whenNotPaused {
        _getReward(msg.sender);
    }

    ///@notice User harvest function for one reward tokens
    function getReward(address _token) external nonReentrant whenNotPaused {
        address _account = msg.sender;
        _updateReward(_account, _token);
        uint256 reward = _rewards[_account][_token];
        if (reward > 0) {
            _rewards[_account][_token] = 0;
            IERC20(_token).safeTransfer(_account, reward);
            emit Harvest(_account, _token, reward);
        }

    }

    function _getReward(address _account) internal {
        _updateAllRewards(_account);
        uint256 i;
        uint256 len = rewardTokens.length;
        address _token;
        for(i; i < len; i++){
            _token = rewardTokens[i];
            uint256 reward = _rewards[_account][_token];
            if (reward > 0) {
                _rewards[_account][_token] = 0;
                IERC20(_token).safeTransfer(_account, reward);
                emit Harvest(_account, _token, reward);
            }
        }
    }


    /* -----------------------------------------------------------------------------
    --------------------------------------------------------------------------------
                                    INTERNAL
    --------------------------------------------------------------------------------
    ----------------------------------------------------------------------------- */

    /// @notice Update the reward info of all token for a given account
    function _updateAllRewards(address _account) internal {
        uint256 i;
        uint256 len = rewardTokens.length;
        address _token;
        for(i; i < len; i++) {
            _token = rewardTokens[i];
            _updateReward(_account, _token);
        }
    }

    /// @notice Update the reward info of one token for a given account
    /// @dev if address(0) then only update reward token info, else update user _account rewards
    function _updateReward(address _account, address _token) internal {
        uint256 _rPTS = _rewardPerToken(_token);
        _rewardPerTokenStored[_token] = _rPTS;
        _lastUpdateTime[_token] = _lastTimeRewardApplicable(_token);
        if (_account != address(0)) {
            _rewards[_account][_token] = _earned(_account, _token);
            _userRewardPerTokenPaid[_account][_token] = _rPTS;
        }
    }

    /// @notice Find the reward amount of a token for a given user
    /// @dev return all past _rewards with any new rewards
    function _earned(address _account, address _token) internal view returns(uint256) {
        uint256 _newRewards = _balances[_account] * (_rewardPerToken(_token) - _userRewardPerTokenPaid[_account][_token]) / 1e18;
        return  _newRewards + _rewards[_account][_token];
    }

    /// @notice Find the reward of a token for 1 staked token
    function _rewardPerToken(address _token) internal view returns (uint256) {
        uint256 _rewPTS = _rewardPerTokenStored[_token];
        if (_totalSupply == 0) {
            return _rewPTS;
        } else {
            return _rewPTS + (_lastTimeRewardApplicable(_token) - _lastUpdateTime[_token]) * _rewardRate[_token] * 1e18 / _totalSupply;
        }
    }

    /// @notice last time reward was applicable
    function _lastTimeRewardApplicable(address _token) internal view returns (uint256) {
        return GaugeMath._min(block.timestamp, _periodFinish[_token]);
    }

    /* -----------------------------------------------------------------------------
    --------------------------------------------------------------------------------
                                    DISTRIBUTION
    --------------------------------------------------------------------------------
    ----------------------------------------------------------------------------- */

    /// @dev Receive rewards from distribution only
    /// @dev this function receive the tokens before being called
    function notifyRewardAmount(address _token, uint _amount) external nonReentrant isNotEmergency onlyDistribution {
        _notifyRewardAmount(_token, _amount, false);
    }

    /// @dev Receive rewards from distribution only
    /// @dev this function uses safeTransfer from
    function notifyRewardAmountTransferFrom(address _token, uint _amount) external nonReentrant isNotEmergency onlyDistribution {
        _notifyRewardAmount(_token, _amount, true);
    }

    /// @notice Save new incentives
    /// @param _token       token to receive
    /// @param _amount      amount to receive
    /// @param isTransferFrom   if true then needs safeTransferFrom, else gauge has the token
    function _notifyRewardAmount(address _token, uint _amount, bool isTransferFrom) internal {
        _updateReward(address(0), _token);
        require(isRewardToken[_token], '!token');


        uint256 _periodEnd = _periodFinish[_token];

        if (block.timestamp >= _periodEnd) {
            _rewardRate[_token] = _amount / DURATION;
        } else {
            uint256 _rewRate = _rewardRate[_token];
            uint256 leftover = (_periodEnd - block.timestamp) * _rewRate;
            _rewardRate[_token] = (_amount + leftover) / DURATION;
        }

        _lastUpdateTime[_token] = block.timestamp;
        _periodFinish[_token] = block.timestamp + DURATION;

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        if(isTransferFrom) IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        uint256 balance = IERC20(_token).balanceOf(address(this));
        require(_rewardRate[_token] <= balance / DURATION, "!rate");


        emit RewardAdded(_token, _amount);
    }

    /// @notice Claim the Fees earned by the underlying strategy or LP
    function claimFees() external nonReentrant returns (uint claimed0, uint claimed1) {
        require(msg.sender == owner());
        if(isWeighted) return _claimFeesWeighted();
        else {
            return _claimFees();
        }
    }

    /// @dev feeVault for solidly pairs is the pair itself, else an external recipient contract
    function _claimFees() internal returns (uint _claimed0, uint _claimed1) {

        address _token = address(TOKEN);
        (_claimed0, _claimed1) = IFeeVault(feeVault).claimFees();

        (address _token0) = IPairInfo(_token).token0();
        (address _token1) = IPairInfo(_token).token1();
        if (_claimed0  > 0) {
            IERC20(_token0).safeIncreaseAllowance(address(votingIncentives), _claimed0);
            votingIncentives.notifyRewardAmount(_token0, _claimed0);
        }

        if (_claimed1  > 0) {
            IERC20(_token1).safeIncreaseAllowance(address(votingIncentives), _claimed1);
            votingIncentives.notifyRewardAmount(_token1, _claimed1);
        }


        emit ClaimFees(msg.sender, _claimed0, _claimed1);

    }


    function _claimFeesWeighted() internal returns (uint _claimed0, uint _claimed1) {
        IWeightedPoolsSimple _feeVault = IWeightedPoolsSimple(feeVault);

        uint256[] memory _expectedFees = _feeVault.expectedFees(address(this));
        (bool success, ) = address(feeVault).call(abi.encodeWithSignature("claimFees()"));
        require(success, "claimFees() call failed");
        uint256 _totalTokens = _feeVault.totalTokens();

        for(uint256 i = 0; i < _totalTokens; i++) {
            address _token = _feeVault.tokens(i);
            uint256 _amount = _expectedFees[i];
            if(_amount > 0 && _amount <= IERC20(_token).balanceOf(address(this))) {
                IERC20(_token).safeIncreaseAllowance(address(votingIncentives), _amount);
                votingIncentives.notifyRewardAmount(_token, _amount);
            }
        }
        return (0,0);
    }

}
